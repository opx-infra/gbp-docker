#!/usr/bin/env python3
"""Simple program to manage gbp-docker container lifecycle."""

import argparse
import logging
import os
import shutil
import sys

from pathlib import Path
from subprocess import run, PIPE, DEVNULL
from typing import List

PWD = Path.cwd()
UID = os.getuid()
GID = os.getgid()
USER = os.getenv("USER")

CONTAINER_NAME = "{}-dbp-{}".format(USER, PWD.stem)
IMAGE = "opxhub/gbp"


def container_exists(dist: str) -> bool:
    """Returns true if our dbp container can be inspected"""
    p = run(["docker", "inspect", CONTAINER_NAME], stdout=DEVNULL, stderr=DEVNULL)
    return p.returncode == 0


def container_running(dist: str) -> bool:
    """Returns true if our dbp container is running"""
    p = run(
        ["docker", "inspect", CONTAINER_NAME, "--format={{.State.Running}}"],
        stdout=PIPE,
        stderr=DEVNULL,
    )
    return p.returncode == 0 and "true" in str(p.stdout)


def buildpackage(dist: str, target: str, gbp_options: List[str]) -> int:
    """Runs gbp buildpackage --git-export-dir=pool/{dist}-amd64/{target}

    Uses (and starts if necessary) any matching pre-existing dbp container.
    """
    if container_exists(dist):
        cmd = [
            "docker",
            "exec",
            "-it",
            "--user=build",
            "-e=EXTRA_SOURCES",
            CONTAINER_NAME,
            "build",
            target,
            " ".join(gbp_options),
        ]
        if not container_running(dist):
            docker_start(dist)
    else:
        cmd = [
            "docker",
            "run",
            "--name={}".format(CONTAINER_NAME),
            "--rm",
            "-it",
            "-v={}:/mnt".format(PWD),
            "-v={}/.gitconfig:/etc/skel/.gitconfig:ro".format(Path.home()),
            "-e=UID={}".format(UID),
            "-e=GID={}".format(GID),
            "-e=EXTRA_SOURCES",
            "--hostname={}".format(dist),
            "{}:{}".format(IMAGE, dist),
            "build",
            target,
            " ".join(gbp_options),
        ]

    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    return proc.returncode


def docker_run(dist: str) -> int:
    """Runs bash in a development container

    Uses (and starts if necessary) any matching pre-existing dbp container.
    """
    if container_exists(dist):
        cmd = [
            "docker",
            "exec",
            "-it",
            "--user=build",
            "-e=EXTRA_SOURCES",
            CONTAINER_NAME,
            "bash",
        ]
        if not container_running(dist):
            docker_start(dist)
    else:
        cmd = [
            "docker",
            "run",
            "--name={}".format(CONTAINER_NAME),
            "-it",
            "-v={}:/mnt".format(PWD),
            "-v={}/.gitconfig:/etc/skel/.gitconfig:ro".format(Path.home()),
            "-e=UID={}".format(UID),
            "-e=GID={}".format(GID),
            "-e=EXTRA_SOURCES",
            "--hostname={}".format(dist),
            "{}:{}-dev".format(IMAGE, dist),
        ]

    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    return proc.returncode


def docker_start(dist: str) -> int:
    """Runs docker start and returns the return code"""
    cmd = ["docker", "start", CONTAINER_NAME]
    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    return proc.returncode


def pull_images(dist: str) -> int:
    """Runs docker pull for both build and development images and returns the return code"""
    cmd = ["docker", "pull", "{}:{}".format(IMAGE, dist)]
    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    if proc.returncode != 0:
        return proc.returncode

    cmd = ["docker", "pull", "{}:{}-dev".format(IMAGE, dist)]
    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    return proc.returncode


def remove_container() -> int:
    """Runs docker rm -f for the dbp container and always returns 0"""
    cmd = ["docker", "rm", "-f", CONTAINER_NAME]
    proc = run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    # we don't care if it doesn't exist
    return 0


def cmd_build(args: argparse.Namespace) -> int:
    # TODO: support building multiple repositories at once

    if not args.target.exists():
        logging.error("Build target `{}` does not exist".format(args.target))
        return 1

    return buildpackage(args.dist, str(args.target), args.gbp_options)


def cmd_pull(args: argparse.Namespace) -> int:
    return pull_images(args.dist)


def cmd_rm(args: argparse.Namespace) -> int:
    return remove_container()


def cmd_run(args: argparse.Namespace) -> int:
    return docker_run(args.dist)


def main() -> int:
    if shutil.which("docker") is None:
        logging.error("Docker not found in PATH. Please install docker.")
        sys.exit(1)

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--verbose", "-v", help="-v for info, -vv for debug", action="count", default=0
    )
    parser.add_argument(
        "--dist", "-d", help="Debian distribution", default=os.getenv("DIST", "stretch")
    )
    parser.add_argument(
        "--extra-sources",
        "-e",
        help="Apt-style sources",
        default=os.getenv("EXTRA_SOURCES", ""),
    )

    sps = parser.add_subparsers(help="commands")
    build_parser = sps.add_parser("build", help="run gbp buildpackage in a container")
    build_parser.add_argument("target", type=Path, help="directory to build")
    build_parser.add_argument("gbp_options", nargs="*")
    build_parser.set_defaults(func=cmd_build)
    pull_parser = sps.add_parser("pull", help="pull latest images")
    pull_parser.set_defaults(func=cmd_pull)
    rm_parser = sps.add_parser("rm", help="remove workspace container")
    rm_parser.set_defaults(func=cmd_rm)
    run_parser = sps.add_parser("run", help="run development container")
    run_parser.set_defaults(func=cmd_run)

    args = parser.parse_args()
    logging.basicConfig(level=10 * (3 - min(args.verbose, 2)))

    # read sources from ./.extra_sources and ~/.extra_sources
    sources_file = Path(".extra_sources")
    if args.extra_sources == "" and sources_file.exists():
        args.extra_sources = sources_file.read_text()
    sources_file = Path.home() / ".extra_sources"
    if args.extra_sources == "" and sources_file.exists():
        args.extra_sources = sources_file.read_text()

    if args.extra_sources != "":
        logging.info("Loaded extra sources:\n{}".format(args.extra_sources))

    if getattr(args, "func", None) is None:
        parser.print_help()
        return 0

    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
